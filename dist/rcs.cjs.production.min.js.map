{"version":3,"file":"rcs.cjs.production.min.js","sources":["../src/Slider/utils.ts","../src/Slider/modes.ts","../src/utils.ts","../src/Rail/Rail.tsx","../src/Handles/Handles.tsx","../src/scales/LinearScale.ts","../src/Ticks/Ticks.tsx","../src/Tracks/Tracks.tsx","../src/scales/DiscreteScale.ts","../src/scales/CurvedScale.ts","../src/Slider/Slider.tsx"],"sourcesContent":["import React from 'react';\nimport warning from 'warning';\n\nimport { DiscreteScale } from '../scales/DiscreteScale';\nimport { HandleItem } from '../types';\n\nexport const prfx = 'react-compound-slider:';\n\nexport function getSortByVal(reversed: boolean = false) {\n  return function sortByVal(a: HandleItem, b: HandleItem) {\n    if (a.val > b.val) {\n      return reversed ? -1 : 1;\n    }\n\n    if (b.val > a.val) {\n      return reversed ? 1 : -1;\n    }\n\n    return 0;\n  };\n}\n\nexport function getUpdatedHandles(\n  handles: HandleItem[],\n  updateKey: string,\n  updateValue: number,\n  reversed: boolean = false\n) {\n  const index = handles.findIndex(v => v.key === updateKey);\n\n  if (index !== -1) {\n    const { key, val } = handles[index];\n\n    if (val === updateValue) {\n      return handles;\n    }\n\n    return [\n      ...handles.slice(0, index),\n      { key, val: updateValue },\n      ...handles.slice(index + 1),\n    ].sort(getSortByVal(reversed));\n  }\n\n  return handles;\n}\n\nexport function getSliderDomain(slider: Element | null, vertical: boolean) {\n  if (!slider) {\n    return [0, 0];\n  }\n\n  const s = slider.getBoundingClientRect();\n\n  const d0 = vertical ? s.top : s.left;\n  const d1 = vertical ? s.bottom : s.right;\n\n  return [d0, d1];\n}\n\nexport function isNotValidTouch({\n  type = '',\n  touches,\n}: {\n  type: string;\n  touches: TouchEvent['touches'];\n}) {\n  return (\n    !touches ||\n    touches.length > 1 ||\n    (type.toLowerCase() === 'touchend' && touches.length > 0)\n  );\n}\n\nexport function getTouchPosition(\n  vertical: boolean,\n  e: React.TouchEvent | TouchEvent\n) {\n  return vertical ? e.touches[0].clientY : e.touches[0].pageX;\n}\n\nexport function getHandles(\n  values: ReadonlyArray<number> = [],\n  reversed: boolean,\n  valueToStep: DiscreteScale,\n  warn: boolean\n) {\n  let changes = 0;\n\n  const handles = values\n    .map(x => {\n      const val = valueToStep.getValue(x);\n\n      if (x !== val) {\n        changes += 1;\n        warning(\n          !warn,\n          `${prfx} Invalid value encountered. Changing ${x} to ${val}.`\n        );\n      }\n\n      return val;\n    })\n    .map((val, i) => ({ key: `$$-${i}`, val }))\n    .sort(getSortByVal(reversed));\n\n  return { handles, changes };\n}\n","import { getUpdatedHandles } from './utils';\nimport { HandleItem } from '../types';\n\n// default mode\nexport function mode1(_: HandleItem[], next: HandleItem[]) {\n  return next;\n}\n\n// prevent duplicate values and crossing\nexport function mode2(curr: HandleItem[], next: HandleItem[]) {\n  for (let i = 0; i < curr.length; i++) {\n    if (curr[i].key !== next[i].key) {\n      return curr;\n    }\n\n    if (next[i + 1] && next[i].val === next[i + 1].val) {\n      return curr;\n    }\n  }\n\n  return next;\n}\n\n// pushable mode\nexport function mode3(\n  curr: HandleItem[],\n  next: HandleItem[],\n  step: number,\n  reversed: boolean,\n  getValue: (x: number) => number\n): HandleItem[] {\n  let indexForMovingHandle = -1;\n  let handleMoveIsPositive = true;\n\n  for (let i = 0; i < curr.length; i++) {\n    const c = curr[i];\n    const n = next[i];\n\n    // make sure keys are in same order if not return curr\n    if (!n || n.key !== c.key) {\n      return curr;\n    } else if (n.val !== c.val) {\n      indexForMovingHandle = i;\n      handleMoveIsPositive = n.val - c.val > 0;\n    }\n  }\n\n  // nothing has changed (shouldn't happen but just in case).\n  if (indexForMovingHandle === -1) {\n    return curr;\n  } else {\n    const increment = handleMoveIsPositive ? step : -step;\n\n    for (let i = 0; i < next.length; i++) {\n      const n0 = next[i];\n      const n1 = next[i + 1];\n\n      if (n1 && n0.val === n1.val) {\n        if (i === indexForMovingHandle) {\n          const newStep = n1.val + increment;\n          if (getValue(newStep) === newStep) {\n            const clone = getUpdatedHandles(\n              next,\n              n1.key,\n              n1.val + increment,\n              reversed\n            );\n            const check = mode3(next, clone, step, reversed, getValue);\n\n            if (check === next) {\n              return curr;\n            } else {\n              return check;\n            }\n          } else {\n            return curr;\n          }\n        } else {\n          const newStep = n0.val + increment;\n          if (getValue(newStep) === newStep) {\n            const clone = getUpdatedHandles(\n              next,\n              n0.key,\n              n0.val + increment,\n              reversed\n            );\n            const check = mode3(next, clone, step, reversed, getValue);\n\n            if (check === next) {\n              return curr;\n            } else {\n              return check;\n            }\n          } else {\n            return curr;\n          }\n        }\n      }\n    }\n  }\n\n  return next;\n}\n","export function callAll<T>(...fns: (((e: T) => void) | undefined)[]) {\n  return (e: T) => {\n    return fns.forEach(fn => fn && fn(e));\n  };\n}\n","import React, { Component } from 'react';\nimport { callAll } from '../utils';\n\nimport { OtherProps } from '../types';\nimport { RailProps } from './types';\n\nconst NOOP = () => ({ value: 0, percent: 0 });\n\nexport class Rail extends Component<RailProps> {\n  getRailProps = (props: OtherProps = {}) => {\n    const { emitMouse, emitTouch } = this.props;\n\n    return {\n      ...props,\n      onMouseDown: callAll<React.MouseEvent<Element>>(\n        props && props.onMouseDown,\n        emitMouse\n      ),\n      onTouchStart: callAll(props && props.onTouchStart, emitTouch),\n    };\n  };\n\n  render() {\n    const {\n      getRailProps,\n      props: { getEventData, activeHandleID = '', children },\n    } = this;\n\n    const renderedChildren = children({\n      getEventData: getEventData || NOOP,\n      activeHandleID,\n      getRailProps,\n    });\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n","import React, { Component } from 'react';\nimport { callAll } from '../utils';\n\nimport { OtherProps } from '../types';\nimport { HandlesProps } from './types';\n\nexport class Handles extends Component<HandlesProps> {\n  autofocus = (e: React.MouseEvent<Element>) => {\n    if (e.target instanceof HTMLElement) {\n      e.target.focus();\n    }\n  };\n\n  getHandleProps = (id: string, props: OtherProps = {}) => {\n    const { emitKeyboard, emitMouse, emitTouch } = this.props;\n\n    return {\n      ...props,\n      onKeyDown: callAll<React.KeyboardEvent<Element>>(\n        props && props.onKeyDown,\n        (e: React.KeyboardEvent<Element>) => emitKeyboard && emitKeyboard(e, id)\n      ),\n      onMouseDown: callAll<React.MouseEvent<Element>>(\n        props && props.onMouseDown,\n        this.autofocus,\n        (e: React.MouseEvent) => emitMouse && emitMouse(e, id)\n      ),\n      onTouchStart: callAll<React.TouchEvent<Element>>(\n        props && props.onTouchStart,\n        (e: React.TouchEvent<Element>) => emitTouch && emitTouch(e, id)\n      ),\n    };\n  };\n\n  render() {\n    const {\n      getHandleProps,\n      props: { activeHandleID = '', children, handles = [] },\n    } = this;\n\n    const renderedChildren = children({\n      handles,\n      activeHandleID,\n      getHandleProps,\n    });\n\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n","import { ticks } from 'd3-array';\n\nimport { Interpolator } from '../types';\n\nfunction clamp(value: number, min: number, max: number) {\n    return Math.min(Math.max(value, min), max);\n}\n\nexport class LinearScale {\n  interpolator: Interpolator | null;\n  domain: number[] = [0, 1];\n  range: number[] = [0, 1];\n  curved: boolean = true;\n\n  constructor() {\n    this.domain = [0, 1];\n    this.range = [0, 1];\n    this.interpolator = null;\n  }\n\n  createInterpolator(domain: number[], range: number[]) {\n    const d0 = domain[0];\n    const d1 = domain[1];\n\n    const r0 = range[0];\n    const r1 = range[1];\n\n    if (d1 < d0) {\n      return (x: number) =>\n        this.interpolateValue(r1, r0)(this.deinterpolateValue(d1, d0)(x));\n    } else {\n      return (x: number) =>\n        this.interpolateValue(r0, r1)(this.deinterpolateValue(d0, d1)(x));\n    }\n  }\n\n  interpolateValue(a: number, b: number) {\n    return (\n      (a = +a),\n      (b -= a),\n      function i(t: number) {\n        return a + b * t;\n      }\n    );\n  }\n\n  deinterpolateValue(a: number, b: number) {\n    return (b -= a = +a) ? (x: number) => (x - a) / b : () => b;\n  }\n\n  rescale() {\n    this.interpolator = null;\n\n    return this;\n  }\n\n  getValue(x: number) {\n    if (!this.curved) {\n        const { domain, range } = this;\n        return (\n            this.interpolator ||\n            (this.interpolator = this.createInterpolator(domain, range))\n        )(+x);\n    }\n    // for our code, x axis is slider (0 to 100); y axis is price (min to max price)\n    // for this part, even tho var name is \"x\", it is referring to our price (y)\n    // here domain is price; range is slider\n    // given a price (y), we want to find the position in the slider range (x)\n    const { domain, range } = this;\n    const retVal = this.getPositionFromPrice(x);\n    console.log(`Y->X||= x: ${x} | Domain: ${domain} | Range: ${range} | Ret Val: ${retVal}`);\n    return retVal;\n  }\n\n  setDomain(val: number[]) {\n    this.domain = [val[0], val[1]];\n\n    this.rescale();\n\n    return this;\n  }\n\n  getDomain() {\n    return this.domain;\n  }\n\n  setRange(val: number[]) {\n    this.range = [val[0], val[1]];\n\n    return this;\n  }\n\n  getRange() {\n    return this.range;\n  }\n\n  getTicks(count: number) {\n    const d = this.curved ? this.range : this.domain;   // we want to use slider values as our stuff is curved\n    return ticks(d[0], d[d.length - 1], count ? count : 10);\n  }\n\n    getPositionFromPrice = (y: number) => {\n        // for our code, a to z is y axis i.e., price\n        // r to s is x axis i.e., slider\n        const {\n            // @ts-ignore\n            domain: [a, z],\n            // @ts-ignore\n            range: [r, s]\n        } = this;\n\n        // const r = 0;\n        // const s = 100;\n        // standard ellipse eq: x^2/a^2 + y^2/b^2 = 1 where -a<=x<=a\n        // converting to our coordinates:\n\n        //         |\n        //         |z    *\n        //         |    *\n        //         |  .*\n        // –―–―–―–―|*―–―–―–―\n        //         |r    s\n        //         |\n        //         |-z\n        //         |\n\n        // standard eq becomes a z unit translate in y axis hence the (y-z)^2 instead of y^2\n        // https://www.desmos.com/calculator/xwzob4hpgo\n        return s * Math.sqrt((1 - (y - z) * (y - z) / (z * z)));    //x\n    }\n\n    // this is opposite function of above; give x and get y\n    getValueFromPosition = (x: number) => {\n        const {\n            // @ts-ignore\n            domain: [a, z],\n            // @ts-ignore\n            range: [r, s]\n        } = this;\n\n        // @ts-ignore\n        // const r = 0;\n        // const s = 100;\n        // we add a - at start since we want the bottom part of curve and a +z transform along y\n        return Math.round(-z * Math.sqrt((1 - (x * x) / (s * s))) + z); // y\n    }\n\n    getValueFromPixel = (x: number) => {\n        const {\n            domain: [a, z],\n            range: [r, s],\n        } = this;\n\n        const step = 100;\n        const p = (clamp(x, r, s) - r) / (s - r);   // percentage (0 to 1)\n        const b = step * Math.round(this.getValueFromPosition(p * 100) / step); // round to step int\n        console.log(`P->X->Y||= x: ${x} | Domain: ${this.domain} | Range: ${this.range} | Ret Val: ${b}`);\n\n        return clamp(b, a < z ? a : z, z > a ? z : a);\n    };\n}\n","import React, { Component } from 'react';\n\nimport { TicksProps } from './types';\nimport { LinearScale } from '../scales/LinearScale';\n\nconst defaultGetEventData = () => ({ value: 0, percent: 0 });\n\nexport class Ticks extends Component<TicksProps> {\n  public render() {\n    const {\n      children,\n      values,\n      scale = new LinearScale(),\n      count = 10,\n      getEventData = defaultGetEventData,\n      activeHandleID = '',\n    } = this.props;\n\n    const ticks = (values ? values : scale.getTicks(count)).map((value) => ({\n      id: `$$-${value}`,\n      value: scale.getValueFromPixel(value),\n      percent: value,\n    }));\n\n    const renderedChildren = children({ getEventData, activeHandleID, ticks });\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n","import React, { Component } from 'react';\n\nimport { callAll } from '../utils';\nimport { LinearScale } from '../scales/LinearScale';\nimport { TracksProps } from './types';\nimport { OtherProps } from '../types';\n\nconst defaultGetEventData = () => ({ value: 0, percent: 0 });\n\nexport class Tracks extends Component<TracksProps> {\n  getTrackProps = (props?: OtherProps) => {\n    const { emitMouse, emitTouch } = this.props;\n\n    return {\n      ...(props || {}),\n      onMouseDown: callAll<React.MouseEvent<Element>>(\n        props && props.onMouseDown,\n        emitMouse\n      ),\n      onTouchStart: callAll<React.TouchEvent<Element>>(\n        props && props.onTouchStart,\n        emitTouch\n      ),\n    };\n  };\n\n  render() {\n    const {\n      getTrackProps,\n      props: {\n        children,\n        left = true,\n        right = true,\n        scale = new LinearScale(),\n        handles = [],\n        getEventData = defaultGetEventData,\n        activeHandleID = '',\n      },\n    } = this;\n\n    const domain = scale.getDomain();\n    const tracks = [];\n\n    for (let i = 0; i < handles.length + 1; i++) {\n      let source = handles[i - 1];\n      let target = handles[i];\n\n      if (i === 0 && left === true) {\n        source = { id: '$', value: domain[0], percent: 0 };\n      } else if (i === handles.length && right === true) {\n        target = { id: '$', value: domain[1], percent: 100 };\n      }\n\n      if (source && target) {\n        tracks.push({\n          id: `${source.id}-${target.id}`,\n          source,\n          target,\n        });\n      }\n    }\n\n    const renderedChildren = children({\n      getEventData,\n      activeHandleID,\n      tracks,\n      getTrackProps,\n    });\n\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n","function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max);\n}\n\nexport class DiscreteScale {\n  step: number = 1;\n  domain: number[] = [0, 1];\n  range: number[] = [0, 1];\n\n  setDomain = (val: number[]) => {\n    this.domain = [val[0], val[1]];\n\n    return this;\n  };\n\n  setRange = (val: number[]) => {\n    this.range = [val[0], val[1]];\n\n    return this;\n  };\n\n  setStep = (val: number) => {\n    this.step = val;\n\n    return this;\n  };\n\n  getValue = (x: number) => {\n    const {\n      domain: [d0, d1],\n      range: [r0, r1],\n      step,\n    } = this;\n\n    const p = (clamp(x, d0, d1) - d0) / (d1 - d0);\n    const b = step * Math.round((p * (r1 - r0)) / step) + r0;\n\n    return clamp(b, r0 < r1 ? r0 : r1, r1 > r0 ? r1 : r0);\n  };\n}\n","function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max);\n}\n\nexport class CurvedScale {\n  step: number = 1;\n  domain: number[] = [0, 1];\n  range: number[] = [0, 1];\n\n  getRange() {\n    return this.range;\n  }\n  getDomain() {\n    return this.domain;\n  }\n\n  setDomain = (val: number[]) => {\n    this.domain = [val[0], val[1]];\n\n    return this;\n  };\n\n  setRange = (val: number[]) => {\n    this.range = [val[0], val[1]];\n\n    return this;\n  };\n\n  setStep = (val: number) => {\n    this.step = val;\n\n    return this;\n  };\n\n  getValue = (x: number) => {\n    const {\n      domain: [a, z],\n      range: [r, s],\n      step,\n    } = this;\n\n    const p = (clamp(x, a, z) - a) / (z - a);\n    const b = step * Math.round(this.getValueFromPosition(p * 100)/step);\n    console.log(`(C)X->Y||= x: ${x} | Domain: ${this.domain} | Range: ${this.range} | Ret Val: ${b}`);\n\n    return clamp(b, r < s ? r : s, s > r ? s : r);\n  };\n\n  // this function is slightly different from the one in LinearScale as in the range/domains are different\n  getValueFromPosition = (x: number) => {\n    const {\n      // @ts-ignore\n      range: [a, z],\n    } = this;\n\n    // @ts-ignore\n    const r = 0;\n    const s = 100;\n    return Math.round(-z * Math.sqrt((1 - (x*x)/(s*s))) + z); // y\n  }\n}\n","import React, { PureComponent, isValidElement } from 'react';\nimport warning from 'warning';\nimport { mode1, mode2, mode3 } from './modes';\nimport {\n  isNotValidTouch,\n  getTouchPosition,\n  getUpdatedHandles,\n  getSliderDomain,\n  getHandles,\n  prfx,\n} from './utils';\nimport { Rail } from '../Rail';\nimport { Handles } from '../Handles';\nimport { Ticks } from '../Ticks';\nimport { Tracks } from '../Tracks';\nimport { LinearScale } from '../scales/LinearScale';\nimport { DiscreteScale } from '../scales/DiscreteScale';\nimport { CurvedScale } from '../scales/CurvedScale';\n\nimport { SliderProps, SliderState } from './types';\nimport { HandleItem } from '../types';\n\nconst isBrowser =\n  typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst noop = () => {};\n\nconst compare = (b: any[]) => (m: any, d: any, i: number) => m && b[i] === d;\n\nconst equal = (a: any, b: any) => {\n  return a === b || (a.length === b.length && a.reduce(compare(b), true));\n};\n\ninterface RCSComponent {\n  type: {\n    name: 'Rail' | 'Handles' | 'Ticks' | 'Tracks';\n  };\n}\n\nconst isRCSComponent = (item: React.ReactNode): item is RCSComponent => {\n  if (!isValidElement(item)) {\n    return false;\n  }\n\n  const type = (item as RCSComponent).type;\n  const name = type ? type.name : '';\n\n  return (\n    name === Handles.name ||\n    name === Rail.name ||\n    name === Ticks.name ||\n    name === Tracks.name\n  );\n};\n\nconst getNextValue = (\n  curr: number,\n  step: number,\n  domain: ReadonlyArray<number>,\n  reversed: boolean\n) => {\n  const newVal = reversed ? curr - step : curr + step;\n  return reversed ? Math.max(domain[0], newVal) : Math.min(domain[1], newVal);\n};\n\nconst getPrevValue = (\n  curr: number,\n  step: number,\n  domain: ReadonlyArray<number>,\n  reversed: boolean\n) => {\n  const newVal = reversed ? curr + step : curr - step;\n  return reversed ? Math.min(domain[1], newVal) : Math.max(domain[0], newVal);\n};\n\nconst defaultDomain = [0, 100];\n\nexport class Slider<\n  T extends HTMLDivElement = HTMLDivElement\n> extends PureComponent<SliderProps, SliderState> {\n  state = {\n    step: 0.1,\n    values: [],\n    domain: defaultDomain,\n    handles: [] as HandleItem[],\n    reversed: false,\n    activeHandleID: '',\n    valueToPerc: null,\n    valueToStep: null,\n    pixelToStep: null,\n  };\n\n  slider = React.createRef<T>();\n\n  static getDerivedStateFromProps(\n    nextProps: SliderProps,\n    prevState: SliderState\n  ) {\n    const {\n      step = 0.1,\n      values,\n      domain = defaultDomain,\n      reversed = false,\n      onUpdate = noop,\n      onChange = noop,\n      warnOnChanges = false,\n    } = nextProps;\n    let valueToPerc = prevState.valueToPerc;\n    let valueToStep = prevState.valueToStep;\n    let pixelToStep = prevState.pixelToStep;\n\n    const nextState: Partial<SliderState> = {};\n\n    if (!valueToPerc || !valueToStep || !pixelToStep) {\n      valueToPerc = new LinearScale();\n      valueToStep = new DiscreteScale();\n      pixelToStep = new CurvedScale();\n\n      nextState.valueToPerc = valueToPerc;\n      nextState.valueToStep = valueToStep;\n      nextState.pixelToStep = pixelToStep;\n    }\n\n    if (\n      prevState.domain === defaultDomain ||\n      prevState.step === null ||\n      prevState.domain === null ||\n      prevState.reversed === null ||\n      step !== prevState.step ||\n      domain[0] !== prevState.domain[0] ||\n      domain[1] !== prevState.domain[1] ||\n      reversed !== prevState.reversed\n    ) {\n      const [min, max] = domain;\n      valueToStep.setStep(step).setRange([min, max]).setDomain([min, max]);\n\n      if (reversed === true) {\n        valueToPerc.setDomain([min, max]).setRange([100, 0]);\n        pixelToStep.setStep(step).setRange([max, min]);\n      } else {\n        valueToPerc.setDomain([min, max]).setRange([0, 100]);\n        pixelToStep.setStep(step).setRange([min, max]);\n      }\n\n      warning(\n        max > min,\n        `${prfx} Max must be greater than min (even if reversed). Max is ${max}. Min is ${min}.`\n      );\n\n      const { handles, changes } = getHandles(\n        values || prevState.values,\n        reversed,\n        valueToStep,\n        warnOnChanges\n      );\n\n      if (changes || values === undefined || values === prevState.values) {\n        onUpdate(handles.map((d) => d.val));\n        onChange(handles.map((d) => d.val));\n      }\n\n      nextState.step = step;\n      nextState.values = values;\n      nextState.domain = domain === defaultDomain ? [...domain] : domain;\n      nextState.handles = handles;\n      nextState.reversed = reversed;\n    } else if (!equal(values, prevState.values)) {\n      const { handles, changes } = getHandles(\n        values,\n        reversed,\n        valueToStep,\n        warnOnChanges\n      );\n\n      if (changes) {\n        onUpdate(handles.map((d) => d.val));\n        onChange(handles.map((d) => d.val));\n      }\n\n      nextState.values = values;\n      nextState.handles = handles;\n    }\n\n    if (Object.keys(nextState).length) {\n      return nextState;\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    const { pixelToStep } = this.state;\n    const { vertical } = this.props;\n\n    // @ts-ignore\n    pixelToStep.setDomain(getSliderDomain(this.slider.current, vertical));\n  }\n\n  componentWillUnmount() {\n    this.removeListeners();\n  }\n\n  removeListeners() {\n    if (isBrowser) {\n      document.removeEventListener('mousemove', this.onMouseMove);\n      document.removeEventListener('mouseup', this.onMouseUp);\n      document.removeEventListener('touchmove', this.onTouchMove);\n      document.removeEventListener('touchend', this.onTouchEnd);\n    }\n  }\n\n  onKeyDown = (e: KeyboardEvent, handleID: string) => {\n    let validUpKeys = ['ArrowRight', 'ArrowUp'];\n    let validDownKeys = ['ArrowDown', 'ArrowLeft'];\n\n    const {\n      state: { handles },\n      props: {\n        step = 0.1,\n        reversed = false,\n        vertical = false,\n        domain = [0, 100] as number[],\n      },\n    } = this;\n    const key = e.key || `${e.keyCode}`;\n\n    if (!validUpKeys.concat(validDownKeys).includes(key)) {\n      return;\n    }\n\n    if (vertical) {\n      [validUpKeys, validDownKeys] = [validDownKeys, validUpKeys];\n    }\n\n    e.stopPropagation && e.stopPropagation();\n    e.preventDefault && e.preventDefault();\n\n    const found = handles.find((value) => {\n      return value.key === handleID;\n    });\n\n    if (!found) {\n      return;\n    }\n\n    const currVal = found.val;\n    let newVal = currVal;\n\n    if (validUpKeys.includes(key)) {\n      newVal = getNextValue(currVal, step, domain, reversed);\n    } else if (validDownKeys.includes(key)) {\n      newVal = getPrevValue(currVal, step, domain, reversed);\n    }\n    const nextHandles = handles.map((v) =>\n      v.key === handleID ? { key: v.key, val: newVal } : v\n    );\n\n    this.submitUpdate(nextHandles, true);\n  };\n\n  onMouseDown = (e: MouseEvent, handleID: string) => {\n    this.onStart(e, handleID, false);\n  };\n\n  onTouchStart = (e: TouchEvent, handleID: string) => {\n    if (isNotValidTouch(e)) {\n      return;\n    }\n\n    this.onStart(e, handleID, true);\n  };\n\n  onStart(e: MouseEvent | TouchEvent, handleID: string, isTouch: boolean) {\n    const {\n      state: { handles },\n      props: { onSlideStart = noop },\n    } = this;\n\n    if (!isTouch) {\n      e.preventDefault && e.preventDefault();\n    }\n\n    e.stopPropagation && e.stopPropagation();\n\n    const found = handles.find((value) => {\n      return value.key === handleID;\n    });\n\n    if (found) {\n      this.setState({ activeHandleID: handleID });\n      onSlideStart(\n        handles.map((d) => d.val),\n        { activeHandleID: handleID }\n      );\n      isTouch ? this.addTouchEvents() : this.addMouseEvents();\n    } else {\n      this.setState({ activeHandleID: '' });\n      this.handleRailAndTrackClicks(e, isTouch);\n    }\n  }\n\n  handleRailAndTrackClicks(e: MouseEvent | TouchEvent, isTouch: boolean) {\n    const {\n      state: { handles: curr, pixelToStep },\n      props: { vertical, reversed = false },\n    } = this;\n    const { slider } = this;\n\n    // double check the dimensions of the slider\n    // @ts-ignore\n    pixelToStep.setDomain(getSliderDomain(slider.current, vertical));\n\n    // find the closest value (aka step) to the event location\n    let updateValue: number;\n\n    if (isTouch) {\n      // @ts-ignore\n      updateValue = pixelToStep.getValue(getTouchPosition(vertical, e));\n    } else {\n      // @ts-ignore\n      updateValue = pixelToStep.getValue(vertical ? e.clientY : e.pageX);\n    }\n\n    // find the closest handle key\n    let updateKey = '';\n    let minDiff = Infinity;\n\n    for (let i = 0; i < curr.length; i++) {\n      const { key, val } = curr[i];\n      const diff = Math.abs(val - updateValue);\n\n      if (diff < minDiff) {\n        updateKey = key;\n        minDiff = diff;\n      }\n    }\n\n    // generate a \"candidate\" set of values - a suggestion of what to do\n    const nextHandles = getUpdatedHandles(\n      curr,\n      updateKey,\n      updateValue,\n      reversed\n    );\n\n    // submit the candidate values\n    this.setState({ activeHandleID: updateKey }, () => {\n      this.submitUpdate(nextHandles, true);\n      isTouch ? this.addTouchEvents() : this.addMouseEvents();\n    });\n  }\n\n  getEventData = (e: React.MouseEvent | React.TouchEvent, isTouch: boolean) => {\n    const {\n      state: { pixelToStep, valueToPerc },\n      props: { vertical },\n    } = this;\n\n    // double check the dimensions of the slider\n    // @ts-ignore\n    pixelToStep.setDomain(getSliderDomain(this.slider.current, vertical));\n\n    let value;\n\n    if (isTouch && e instanceof TouchEvent) {\n      // @ts-ignore\n      value = pixelToStep.getValue(getTouchPosition(vertical, e));\n    } else if (e instanceof MouseEvent) {\n      // @ts-ignore\n      value = pixelToStep.getValue(vertical ? e.clientY : e.pageX);\n    }\n    return {\n      value,\n      // @ts-ignore\n      percent: valueToPerc.getValue(value),\n    };\n  };\n\n  addMouseEvents() {\n    if (isBrowser) {\n      document.addEventListener('mousemove', this.onMouseMove);\n      document.addEventListener('mouseup', this.onMouseUp);\n    }\n  }\n\n  addTouchEvents() {\n    if (isBrowser) {\n      document.addEventListener('touchmove', this.onTouchMove);\n      document.addEventListener('touchend', this.onTouchEnd);\n    }\n  }\n\n  onMouseMove = (e: MouseEvent) => {\n    const {\n      state: { handles: curr, pixelToStep, activeHandleID = '' },\n      props: { vertical, reversed = false },\n    } = this;\n    // double check the dimensions of the slider\n    // @ts-ignore\n    pixelToStep.setDomain(getSliderDomain(this.slider.current, vertical));\n\n    // find the closest value (aka step) to the event location\n    // @ts-ignore\n    const updateValue = pixelToStep.getValue(vertical ? e.clientY : e.pageX);\n\n    // generate a \"candidate\" set of values - a suggestion of what to do\n    const nextHandles = getUpdatedHandles(\n      curr,\n      activeHandleID,\n      updateValue,\n      reversed\n    );\n\n    // submit the candidate values\n    this.submitUpdate(nextHandles);\n  };\n\n  onTouchMove = (e: TouchEvent) => {\n    const {\n      state: { handles: curr, pixelToStep, activeHandleID },\n      props: { vertical, reversed },\n    } = this;\n    if (pixelToStep === null || isNotValidTouch(e)) {\n      return;\n    }\n\n    // double check the dimensions of the slider\n    // @ts-ignore\n    pixelToStep.setDomain(getSliderDomain(this.slider.current, vertical));\n\n    // find the closest value (aka step) to the event location\n    // @ts-ignore\n    const updateValue = pixelToStep.getValue(getTouchPosition(vertical, e));\n\n    // generate a \"candidate\" set of values - a suggestion of what to do\n    const nextHandles = getUpdatedHandles(\n      curr,\n      activeHandleID,\n      updateValue,\n      reversed\n    );\n\n    // submit the candidate values\n    this.submitUpdate(nextHandles);\n  };\n\n  submitUpdate(next: HandleItem[], callOnChange = false) {\n    const {\n      mode = 1,\n      step = 0.1,\n      onUpdate = noop,\n      onChange = noop,\n      reversed = false,\n    } = this.props;\n    //@ts-ignore\n    const { getValue } = this.state.valueToStep;\n\n    this.setState(({ handles: curr }) => {\n      let handles: HandleItem[] = [];\n\n      // given the current handles and a candidate set, decide what to do\n      if (typeof mode === 'function') {\n        handles = mode(curr, next, step, reversed, getValue);\n        warning(\n          Array.isArray(handles),\n          'Custom mode function did not return an array.'\n        );\n      } else {\n        switch (mode) {\n          case 1:\n            handles = mode1(curr, next);\n            break;\n          case 2:\n            handles = mode2(curr, next);\n            break;\n          case 3:\n            handles = mode3(curr, next, step, reversed, getValue);\n            break;\n          default:\n            handles = next;\n            warning(false, `${prfx} Invalid mode value.`);\n        }\n      }\n\n      onUpdate(handles.map((d) => d.val));\n\n      if (callOnChange) {\n        onChange(handles.map((d) => d.val));\n      }\n\n      return { handles };\n    });\n  }\n\n  onMouseUp = () => {\n    const {\n      state: { handles = [], activeHandleID },\n      props: { onChange = noop, onSlideEnd = noop },\n    } = this;\n\n    onChange(handles.map((d) => d.val));\n    onSlideEnd(\n      handles.map((d) => d.val),\n      { activeHandleID }\n    );\n\n    this.setState({ activeHandleID: '' });\n\n    if (isBrowser) {\n      document.removeEventListener('mousemove', this.onMouseMove);\n      document.removeEventListener('mouseup', this.onMouseUp);\n    }\n  };\n\n  onTouchEnd = () => {\n    const {\n      state: { handles, activeHandleID },\n      props: { onChange = noop, onSlideEnd = noop },\n    } = this;\n\n    onChange(handles.map((d) => d.val));\n    onSlideEnd(\n      handles.map((d) => d.val),\n      { activeHandleID }\n    );\n\n    this.setState({ activeHandleID: '' });\n\n    if (isBrowser) {\n      document.removeEventListener('touchmove', this.onTouchMove);\n      document.removeEventListener('touchend', this.onTouchEnd);\n    }\n  };\n\n  render() {\n    const {\n      state: { handles, valueToPerc, activeHandleID },\n      props: {\n        className,\n        rootStyle = {},\n        rootProps = {},\n        component: Comp = 'div',\n        disabled = false,\n        flatten = false,\n      },\n    } = this;\n\n    const mappedHandles = handles.map(({ key, val }) => {\n      // @ts-ignore\n      return { id: key, value: val, percent: valueToPerc.getValue(val) };\n    });\n\n    const children = React.Children.map(this.props.children, (child) => {\n      if (isRCSComponent(child) === true) {\n        return React.cloneElement(child as React.ReactElement, {\n          scale: valueToPerc,\n          handles: mappedHandles,\n          activeHandleID,\n          getEventData: this.getEventData,\n          emitKeyboard: disabled ? noop : this.onKeyDown,\n          emitMouse: disabled ? noop : this.onMouseDown,\n          emitTouch: disabled ? noop : this.onTouchStart,\n        });\n      } else {\n        return child;\n      }\n    });\n\n    return flatten ? (\n      <>\n        {React.createElement(Comp, {\n          ...rootProps,\n          style: rootStyle,\n          className: className,\n          ref: this.slider,\n        })}\n        {children}\n      </>\n    ) : (\n      <>\n        {React.createElement(\n          Comp,\n          {\n            ...rootProps,\n            style: rootStyle,\n            className: className,\n            ref: this.slider,\n          },\n          children\n        )}\n      </>\n    );\n  }\n}\n"],"names":["prfx","getSortByVal","reversed","a","b","val","getUpdatedHandles","handles","updateKey","updateValue","index","findIndex","v","key","slice","sort","getSliderDomain","slider","vertical","s","getBoundingClientRect","top","left","bottom","right","isNotValidTouch","type","touches","length","toLowerCase","getTouchPosition","e","clientY","pageX","getHandles","values","valueToStep","warn","changes","map","x","getValue","warning","i","mode1","_","next","mode2","curr","mode3","step","indexForMovingHandle","handleMoveIsPositive","c","n","increment","n0","n1","newStep","check","callAll","fns","forEach","fn","NOOP","value","percent","Rail","Component","getRailProps","props","_this","emitMouse","emitTouch","onMouseDown","onTouchStart","this","activeHandleID","renderedChildren","children","getEventData","React","Children","only","Handles","autofocus","target","HTMLElement","focus","getHandleProps","id","emitKeyboard","onKeyDown","clamp","min","max","Math","LinearScale","interpolator","domain","range","curved","getPositionFromPrice","y","z","sqrt","getValueFromPosition","round","getValueFromPixel","r","p","console","log","d0","d1","r0","r1","_this2","interpolateValue","deinterpolateValue","t","createInterpolator","retVal","rescale","count","d","ticks","defaultGetEventData","Ticks","scale","getTicks","Tracks","getTrackProps","getDomain","tracks","source","push","DiscreteScale","setDomain","setRange","setStep","CurvedScale","isBrowser","window","document","noop","getNextValue","newVal","getPrevValue","defaultDomain","Slider","PureComponent","state","valueToPerc","pixelToStep","createRef","handleID","validUpKeys","validDownKeys","keyCode","concat","includes","stopPropagation","preventDefault","found","find","currVal","nextHandles","submitUpdate","onStart","isTouch","current","TouchEvent","MouseEvent","onMouseMove","onTouchMove","onMouseUp","onChange","onSlideEnd","setState","removeEventListener","onTouchEnd","removeListeners","onSlideStart","addTouchEvents","addMouseEvents","handleRailAndTrackClicks","minDiff","Infinity","diff","abs","addEventListener","callOnChange","mode","onUpdate","Array","isArray","className","rootStyle","rootProps","component","Comp","disabled","flatten","mappedHandles","child","item","isValidElement","name","isRCSComponent","cloneElement","_this3","createElement","style","ref","nextProps","prevState","warnOnChanges","nextState","undefined","reduce","m","compare","Object","keys"],"mappings":"ygHAMO,IAAMA,EAAO,yBAEb,SAASC,QAAaC,iEACpB,SAAmBC,EAAeC,UACnCD,EAAEE,IAAMD,EAAEC,IACLH,GAAY,EAAI,EAGrBE,EAAEC,IAAMF,EAAEE,IACLH,EAAW,GAAK,EAGlB,GAIJ,SAASI,EACdC,EACAC,EACAC,OACAP,0DAEMQ,EAAQH,EAAQI,WAAU,SAAAC,UAAKA,EAAEC,MAAQL,SAEhC,IAAXE,EAAc,OACKH,EAAQG,GAArBG,IAAAA,IAAKR,IAAAA,WAETA,IAAQI,EACHF,EAGF,YACFA,EAAQO,MAAM,EAAGJ,KACpB,CAAEG,IAAAA,EAAKR,IAAKI,MACTF,EAAQO,MAAMJ,EAAQ,KACzBK,KAAKd,EAAaC,WAGfK,EAGF,SAASS,EAAgBC,EAAwBC,OACjDD,QACI,CAAC,EAAG,OAGPE,EAAIF,EAAOG,8BAKV,CAHIF,EAAWC,EAAEE,IAAMF,EAAEG,KACrBJ,EAAWC,EAAEI,OAASJ,EAAEK,OAK9B,SAASC,aACdC,KACAC,IAAAA,eAMGA,GACDA,EAAQC,OAAS,GACO,yBATnB,MASCC,eAAgCF,EAAQC,OAAS,EAIpD,SAASE,EACdZ,EACAa,UAEOb,EAAWa,EAAEJ,QAAQ,GAAGK,QAAUD,EAAEJ,QAAQ,GAAGM,MAGjD,SAASC,QACdC,yDAAgC,GAChCjC,yCACAkC,yCACAC,yCAEIC,EAAU,EAER/B,EAAU4B,EACbI,KAAI,SAAAC,OACGnC,EAAM+B,EAAYK,SAASD,UAE7BA,IAAMnC,IACRiC,GAAW,EACXI,WACGL,YACErC,kDAA4CwC,iBAAQnC,SAIpDA,KAERkC,KAAI,SAAClC,EAAKsC,SAAO,CAAE9B,iBAAW8B,GAAKtC,IAAAA,MACnCU,KAAKd,EAAaC,UAEd,CAAEK,QAAAA,EAAS+B,QAAAA,GCtGb,SAASM,EAAMC,EAAiBC,UAC9BA,EAIF,SAASC,EAAMC,EAAoBF,OACnC,IAAIH,EAAI,EAAGA,EAAIK,EAAKpB,OAAQe,IAAK,IAChCK,EAAKL,GAAG9B,MAAQiC,EAAKH,GAAG9B,WACnBmC,KAGLF,EAAKH,EAAI,IAAMG,EAAKH,GAAGtC,MAAQyC,EAAKH,EAAI,GAAGtC,WACtC2C,SAIJF,EAIF,SAASG,EACdD,EACAF,EACAI,EACAhD,EACAuC,WAEIU,GAAwB,EACxBC,GAAuB,EAElBT,EAAI,EAAGA,EAAIK,EAAKpB,OAAQe,IAAK,KAC9BU,EAAIL,EAAKL,GACTW,EAAIR,EAAKH,OAGVW,GAAKA,EAAEzC,MAAQwC,EAAExC,WACbmC,EACEM,EAAEjD,MAAQgD,EAAEhD,MACrB8C,EAAuBR,EACvBS,EAAuBE,EAAEjD,IAAMgD,EAAEhD,IAAM,OAKb,IAA1B8C,SACKH,UAEDO,EAAYH,EAAuBF,GAAQA,EAExCP,EAAI,EAAGA,EAAIG,EAAKlB,OAAQe,IAAK,KAC9Ba,EAAKV,EAAKH,GACVc,EAAKX,EAAKH,EAAI,MAEhBc,GAAMD,EAAGnD,MAAQoD,EAAGpD,IAAK,IACvBsC,IAAMQ,EAAsB,KACxBO,EAAUD,EAAGpD,IAAMkD,KACrBd,EAASiB,KAAaA,EAAS,KAO3BC,EAAQV,EAAMH,EANNxC,EACZwC,EACAW,EAAG5C,IACH4C,EAAGpD,IAAMkD,EACTrD,GAE+BgD,EAAMhD,EAAUuC,UAE7CkB,IAAUb,EACLE,EAEAW,SAGFX,MAGHU,EAAUF,EAAGnD,IAAMkD,KACrBd,EAASiB,KAAaA,EAAS,KAO3BC,EAAQV,EAAMH,EANNxC,EACZwC,EACAU,EAAG3C,IACH2C,EAAGnD,IAAMkD,EACTrD,GAE+BgD,EAAMhD,EAAUuC,UAE7CkB,IAAUb,EACLE,EAEAW,SAGFX,UAOVF,ECrGF,SAASc,+BAAcC,2BAAAA,yBACrB,SAAC9B,UACC8B,EAAIC,SAAQ,SAAAC,UAAMA,GAAMA,EAAGhC,OCItC,IAAMiC,EAAO,iBAAO,CAAEC,MAAO,EAAGC,QAAS,IAE5BC,kBAAaC,wKACxBC,aAAe,eAACC,yDAAoB,KACDC,EAAKD,MAA9BE,IAAAA,UAAWC,IAAAA,wBAGdH,OACHI,YAAad,EACXU,GAASA,EAAMI,YACfF,GAEFG,aAAcf,EAAQU,GAASA,EAAMK,aAAcF,wCAIvD,iBAIMG,KADFN,UAAuBO,eAGnBC,GAAmBC,IAHqBA,UAGZ,CAChCC,eAJSA,cAIqBhB,EAC9Ba,0BALwC,KAMxCR,aALEO,KAFFP,sBASKS,GAAoBG,UAAMC,SAASC,KAAKL,YC3BtCM,kBAAgBhB,wKAC3BiB,UAAY,SAACtD,GACPA,EAAEuD,kBAAkBC,aACtBxD,EAAEuD,OAAOE,WAIbC,eAAiB,SAACC,OAAYpB,yDAAoB,KACDC,EAAKD,MAA5CqB,IAAAA,aAAcnB,IAAAA,UAAWC,IAAAA,wBAG5BH,OACHsB,UAAWhC,EACTU,GAASA,EAAMsB,WACf,SAAC7D,UAAoC4D,GAAgBA,EAAa5D,EAAG2D,MAEvEhB,YAAad,EACXU,GAASA,EAAMI,YACfH,EAAKc,WACL,SAACtD,UAAwByC,GAAaA,EAAUzC,EAAG2D,MAErDf,aAAcf,EACZU,GAASA,EAAMK,cACf,SAAC5C,UAAiC0C,GAAaA,EAAU1C,EAAG2D,2CAKlE,iBAIMd,KADFN,UAASO,mBAA+BtE,QAGpCuE,GAAmBC,IAHOA,UAGE,CAChCxE,mBAJkD,KAKlDsE,0BAL0B,KAM1BY,eALEb,KAFFa,wBAUKX,GAAoBG,UAAMC,SAASC,KAAKL,YC1CnD,SAASe,EAAM5B,EAAe6B,EAAaC,UAChCC,KAAKF,IAAIE,KAAKD,IAAI9B,EAAO6B,GAAMC,OAG7BE,oDACXC,yBACAC,OAAmB,CAAC,EAAG,QACvBC,MAAkB,CAAC,EAAG,QACtBC,QAAkB,OAyFhBC,qBAAuB,SAACC,OAKJC,IAGZjC,EAHA4B,sBAGA5B,EADA6B,YAoBOJ,KAAKS,KAAM,GAAKF,EAAIC,IAAMD,EAAIC,IAAMA,EAAIA,UAIvDE,qBAAuB,SAAClE,OAGJgE,IAGZjC,EAHA4B,aAEWhF,IACXoD,EADA6B,mBAOGJ,KAAKW,OAAOH,EAAIR,KAAKS,KAAM,EAAKjE,EAAIA,GAAMrB,EAAIA,IAAOqF,SAGhEI,kBAAoB,SAACpE,WAIb+B,EAFA4B,UAAShG,OAAGqG,WAEZjC,EADA6B,SAAQS,OAAG1F,OAIT2F,GAAKjB,EAAMrD,EAAGqE,EAAG1F,GAAK0F,IAAM1F,EAAI0F,GAChCzG,EAFO,IAEI4F,KAAKW,MAAMpC,EAAKmC,qBAAyB,IAAJI,GAFzC,YAGbC,QAAQC,4BAAqBxE,wBAAe+B,EAAK4B,4BAAmB5B,EAAK6B,6BAAoBhG,IAEtFyF,EAAMzF,EAAGD,EAAIqG,EAAIrG,EAAIqG,EAAGA,EAAIrG,EAAIqG,EAAIrG,SA/I1CgG,OAAS,CAAC,EAAG,QACbC,MAAQ,CAAC,EAAG,QACZF,aAAe,iDAGtB,SAAmBC,EAAkBC,cAC7Ba,EAAKd,EAAO,GACZe,EAAKf,EAAO,GAEZgB,EAAKf,EAAM,GACXgB,EAAKhB,EAAM,UAEbc,EAAKD,EACA,SAACzE,UACN6E,EAAKC,iBAAiBF,EAAID,EAA1BE,CAA8BA,EAAKE,mBAAmBL,EAAID,EAA5BI,CAAgC7E,KAEzD,SAACA,UACN6E,EAAKC,iBAAiBH,EAAIC,EAA1BC,CAA8BA,EAAKE,mBAAmBN,EAAIC,EAA5BG,CAAgC7E,qCAIpE,SAAiBrC,EAAWC,UAGvBA,GADAD,GAAKA,EAEN,SAAWqH,UACFrH,EAAIC,EAAIoH,qCAKrB,SAAmBrH,EAAWC,UACpBA,GAAKD,GAAKA,GAAK,SAACqC,UAAeA,EAAIrC,GAAKC,GAAI,kBAAMA,0BAG5D,uBACO8F,aAAe,KAEbtB,6BAGT,SAASpC,OACFoC,KAAKyB,cAGFzB,KAAKsB,eACJtB,KAAKsB,aAAetB,KAAK6C,mBAHJ7C,KAAlBuB,OAAkBvB,KAAVwB,UAIb5D,OAMC2D,EAAkBvB,KAAlBuB,OAAQC,EAAUxB,KAAVwB,MACVsB,EAAS9C,KAAK0B,qBAAqB9D,UACzCuE,QAAQC,yBAAkBxE,wBAAe2D,uBAAmBC,yBAAoBsB,IACzEA,2BAGT,SAAUrH,eACH8F,OAAS,CAAC9F,EAAI,GAAIA,EAAI,SAEtBsH,UAEE/C,8BAGT,kBACSA,KAAKuB,+BAGd,SAAS9F,eACF+F,MAAQ,CAAC/F,EAAI,GAAIA,EAAI,IAEnBuE,6BAGT,kBACSA,KAAKwB,8BAGd,SAASwB,OACDC,EAAIjD,KAAKyB,OAASzB,KAAKwB,MAAQxB,KAAKuB,cACnC2B,QAAMD,EAAE,GAAIA,EAAEA,EAAEjG,OAAS,GAAIgG,GAAgB,aC7FlDG,EAAsB,iBAAO,CAAE9D,MAAO,EAAGC,QAAS,IAE3C8D,kBAAc5D,8GACzB,iBAQMQ,KAAKN,MANPS,IAAAA,SACA5C,IAAAA,WACA8F,MAAAA,aAAQ,IAAIhC,QACZ2B,UACA5C,iBACAH,eASIC,EAAmBC,EAAS,CAAEC,wBAVnB+C,IAUiClD,0BAT/B,KAS+CiD,OANnD3F,GAAkB8F,EAAMC,oBAL7B,OAK8C3F,KAAI,SAAC0B,SAAW,CACtEyB,gBAAUzB,GACVA,MAAOgE,EAAMrB,kBAAkB3C,GAC/BC,QAASD,eAIJa,GAAoBG,UAAMC,SAASC,KAAKL,YClB7CiD,EAAsB,iBAAO,CAAE9D,MAAO,EAAGC,QAAS,IAE3CiE,kBAAe/D,wKAC1BgE,cAAgB,SAAC9D,SACkBC,EAAKD,MAA9BE,IAAAA,UAAWC,IAAAA,wBAGbH,GAAS,QACbI,YAAad,EACXU,GAASA,EAAMI,YACfF,GAEFG,aAAcf,EACZU,GAASA,EAAMK,aACfF,wCAKN,mBAEI2D,EAUExD,KAVFwD,gBAUExD,KATFN,MACES,IAAAA,aACAzD,KAAAA,oBACAE,MAAAA,oBACAyG,MAAAA,aAAQ,IAAIhC,QACZ1F,QAAAA,aAAU,SACVyE,aAAAA,aAAe+C,QACflD,eAAAA,aAAiB,KAIfsB,EAAS8B,EAAMI,YACfC,EAAS,GAEN3F,EAAI,EAAGA,EAAIpC,EAAQqB,OAAS,EAAGe,IAAK,KACvC4F,EAAShI,EAAQoC,EAAI,GACrB2C,EAAS/E,EAAQoC,GAEX,IAANA,IAAoB,IAATrB,EACbiH,EAAS,CAAE7C,GAAI,IAAKzB,MAAOkC,EAAO,GAAIjC,QAAS,GACtCvB,IAAMpC,EAAQqB,SAAoB,IAAVJ,IACjC8D,EAAS,CAAEI,GAAI,IAAKzB,MAAOkC,EAAO,GAAIjC,QAAS,MAG7CqE,GAAUjD,GACZgD,EAAOE,KAAK,CACV9C,aAAO6C,EAAO7C,eAAMJ,EAAOI,IAC3B6C,OAAAA,EACAjD,OAAAA,QAKAR,EAAmBC,EAAS,CAChCC,aAAAA,EACAH,eAAAA,EACAyD,OAAAA,EACAF,cAAAA,WAGKtD,GAAoBG,UAAMC,SAASC,KAAKL,YCrEnD,SAASe,EAAM5B,EAAe6B,EAAaC,UAClCC,KAAKF,IAAIE,KAAKD,IAAI9B,EAAO6B,GAAMC,OAG3B0C,yCACXvF,KAAe,OACfiD,OAAmB,CAAC,EAAG,QACvBC,MAAkB,CAAC,EAAG,QAEtBsC,UAAY,SAACrI,UACXkE,EAAK4B,OAAS,CAAC9F,EAAI,GAAIA,EAAI,IAEpBkE,QAGToE,SAAW,SAACtI,UACVkE,EAAK6B,MAAQ,CAAC/F,EAAI,GAAIA,EAAI,IAEnBkE,QAGTqE,QAAU,SAACvI,UACTkE,EAAKrB,KAAO7C,EAELkE,QAGT9B,SAAW,SAACD,WAKN+B,EAHF4B,UAASc,OAAIC,WAGX3C,EAFF6B,SAAQe,OAAIC,OACZlE,EACEqB,EADFrB,KAGI4D,GAAKjB,EAAMrD,EAAGyE,EAAIC,GAAMD,IAAOC,EAAKD,UAGnCpB,EAFG3C,EAAO8C,KAAKW,MAAOG,GAAKM,EAAKD,GAAOjE,GAAQiE,EAEtCA,EAAKC,EAAKD,EAAKC,EAAIA,EAAKD,EAAKC,EAAKD,KCrCtD,SAAStB,EAAM5B,EAAe6B,EAAaC,UAClCC,KAAKF,IAAIE,KAAKD,IAAI9B,EAAO6B,GAAMC,OAG3B8C,oDACX3F,KAAe,OACfiD,OAAmB,CAAC,EAAG,QACvBC,MAAkB,CAAC,EAAG,QAStBsC,UAAY,SAACrI,UACXkE,EAAK4B,OAAS,CAAC9F,EAAI,GAAIA,EAAI,IAEpBkE,QAGToE,SAAW,SAACtI,UACVkE,EAAK6B,MAAQ,CAAC/F,EAAI,GAAIA,EAAI,IAEnBkE,QAGTqE,QAAU,SAACvI,UACTkE,EAAKrB,KAAO7C,EAELkE,QAGT9B,SAAW,SAACD,WAKN+B,EAHF4B,UAAShG,OAAGqG,WAGVjC,EAFF6B,SAAQS,OAAG1F,OACX+B,EACEqB,EADFrB,KAGI4D,GAAKjB,EAAMrD,EAAGrC,EAAGqG,GAAKrG,IAAMqG,EAAIrG,GAChCC,EAAI8C,EAAO8C,KAAKW,MAAMpC,EAAKmC,qBAAyB,IAAJI,GAAS5D,UAC/D6D,QAAQC,4BAAqBxE,wBAAe+B,EAAK4B,4BAAmB5B,EAAK6B,6BAAoBhG,IAEtFyF,EAAMzF,EAAGyG,EAAI1F,EAAI0F,EAAI1F,EAAGA,EAAI0F,EAAI1F,EAAI0F,SAI7CH,qBAAuB,SAAClE,OAGTgE,IACTjC,EADF6B,mBAMKJ,KAAKW,OAAOH,EAAIR,KAAKS,KAAM,EAAKjE,EAAEA,OAAagE,sCAjDxD,kBACS5B,KAAKwB,+BAEd,kBACSxB,KAAKuB,gBCSV2C,EACc,oBAAXC,QAA8C,oBAAbC,SAEpCC,EAAO,aA8BPC,EAAe,SACnBlG,EACAE,EACAiD,EACAjG,OAEMiJ,EAASjJ,EAAW8C,EAAOE,EAAOF,EAAOE,SACxChD,EAAW8F,KAAKD,IAAII,EAAO,GAAIgD,GAAUnD,KAAKF,IAAIK,EAAO,GAAIgD,IAGhEC,EAAe,SACnBpG,EACAE,EACAiD,EACAjG,OAEMiJ,EAASjJ,EAAW8C,EAAOE,EAAOF,EAAOE,SACxChD,EAAW8F,KAAKF,IAAIK,EAAO,GAAIgD,GAAUnD,KAAKD,IAAII,EAAO,GAAIgD,IAGhEE,EAAgB,CAAC,EAAG,KAEbC,kBAEHC,4KACRC,MAAQ,CACNtG,KAAM,GACNf,OAAQ,GACRgE,OAAQkD,EACR9I,QAAS,GACTL,UAAU,EACV2E,eAAgB,GAChB4E,YAAa,KACbrH,YAAa,KACbsH,YAAa,QAGfzI,OAASgE,UAAM0E,cAuHf/D,UAAY,SAAC7D,EAAkB6H,OACzBC,EAAc,CAAC,aAAc,WAC7BC,EAAgB,CAAC,YAAa,oBAGvBvJ,IAATiJ,MAASjJ,YACT+D,UACEpB,KAAAA,aAAO,SACPhD,SAAAA,oBACAgB,SAAAA,oBACAiF,OAAAA,aAAS,CAAC,EAAG,OAGXtF,EAAMkB,EAAElB,eAAUkB,EAAEgI,YAErBF,EAAYG,OAAOF,GAAeG,SAASpJ,OAI5CK,EAAU,OACmB,CAAC4I,EAAeD,GAA9CA,OAAaC,OAGhB/H,EAAEmI,iBAAmBnI,EAAEmI,kBACvBnI,EAAEoI,gBAAkBpI,EAAEoI,qBAEhBC,EAAQ7J,EAAQ8J,MAAK,SAACpG,UACnBA,EAAMpD,MAAQ+I,QAGlBQ,OAICE,EAAUF,EAAM/J,IAClB8I,EAASmB,EAETT,EAAYI,SAASpJ,GACvBsI,EAASD,EAAaoB,EAASpH,EAAMiD,EAAQjG,GACpC4J,EAAcG,SAASpJ,KAChCsI,EAASC,EAAakB,EAASpH,EAAMiD,EAAQjG,QAEzCqK,EAAchK,EAAQgC,KAAI,SAAC3B,UAC/BA,EAAEC,MAAQ+I,EAAW,CAAE/I,IAAKD,EAAEC,IAAKR,IAAK8I,GAAWvI,OAGhD4J,aAAaD,GAAa,QAGjC7F,YAAc,SAAC3C,EAAe6H,KACvBa,QAAQ1I,EAAG6H,GAAU,MAG5BjF,aAAe,SAAC5C,EAAe6H,GACzBnI,EAAgBM,MAIf0I,QAAQ1I,EAAG6H,GAAU,MAmF5B5E,aAAe,SAACjD,EAAwC2I,OAUlDzG,aARFuF,MAASE,IAAAA,YAAaD,IAAAA,YACbvI,IAAToD,MAASpD,gBAKXwI,EAAYhB,UAAU1H,EAAgBuD,EAAKtD,OAAO0J,QAASzJ,IAIvDwJ,GAAW3I,aAAa6I,WAE1B3G,EAAQyF,EAAYjH,SAASX,EAAiBZ,EAAUa,IAC/CA,aAAa8I,aAEtB5G,EAAQyF,EAAYjH,SAASvB,EAAWa,EAAEC,QAAUD,EAAEE,QAEjD,CACLgC,MAAAA,EAEAC,QAASuF,EAAYhH,SAASwB,OAkBlC6G,YAAc,SAAC/I,kBAEXyH,MAAkBxG,IAATzC,QAAemJ,IAAAA,gBAAa7E,eAAAA,aAAiB,SACtDP,MAASpD,IAAAA,aAAUhB,SAAAA,gBAIrBwJ,EAAYhB,UAAU1H,EAAgBuD,EAAKtD,OAAO0J,QAASzJ,QAOrDqJ,EAAcjK,EAClB0C,EACA6B,EALkB6E,EAAYjH,SAASvB,EAAWa,EAAEC,QAAUD,EAAEE,OAOhE/B,KAIGsK,aAAaD,MAGpBQ,YAAc,SAAChJ,kBAEXyH,MAAkBxG,IAATzC,QAAemJ,IAAAA,YAAa7E,IAAAA,mBACrCP,MAASpD,IAAAA,SAAUhB,IAAAA,YAED,OAAhBwJ,IAAwBjI,EAAgBM,IAM5C2H,EAAYhB,UAAU1H,EAAgBuD,EAAKtD,OAAO0J,QAASzJ,QAOrDqJ,EAAcjK,EAClB0C,EACA6B,EALkB6E,EAAYjH,SAASX,EAAiBZ,EAAUa,IAOlE7B,KAIGsK,aAAaD,OAmDpBS,UAAY,0BAERxB,UAASjJ,QAAAA,aAAU,KAAIsE,IAAAA,mBACvBP,UAAS2G,aAAiBC,WAAAA,aAAajC,gBAAnBA,KAGb1I,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,QAC9B6K,EACE3K,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,OACrB,CAAEwE,eAAAA,MAGCsG,SAAS,CAAEtG,eAAgB,KAE5BiE,IACFE,SAASoC,oBAAoB,YAAa7G,EAAKuG,aAC/C9B,SAASoC,oBAAoB,UAAW7G,EAAKyG,eAIjDK,WAAa,0BAET7B,MAASjJ,IAAAA,QAASsE,IAAAA,mBAClBP,UAAS2G,aAAiBC,WAAAA,aAAajC,gBAAnBA,KAGb1I,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,QAC9B6K,EACE3K,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,OACrB,CAAEwE,eAAAA,MAGCsG,SAAS,CAAEtG,eAAgB,KAE5BiE,IACFE,SAASoC,oBAAoB,YAAa7G,EAAKwG,aAC/C/B,SAASoC,oBAAoB,WAAY7G,EAAK8G,2DApVlD,WAC0BzG,KAAK4E,MAArBE,YAIIhB,UAAU1H,EAAgB4D,KAAK3D,OAAO0J,QAH7B/F,KAAKN,MAAlBpD,+CAMV,gBACOoK,iDAGP,WACMxC,IACFE,SAASoC,oBAAoB,YAAaxG,KAAKkG,aAC/C9B,SAASoC,oBAAoB,UAAWxG,KAAKoG,WAC7ChC,SAASoC,oBAAoB,YAAaxG,KAAKmG,aAC/C/B,SAASoC,oBAAoB,WAAYxG,KAAKyG,oCAiElD,SAAQtJ,EAA4B6H,EAAkBc,OAEzCnK,EAEPqE,KAFF4E,MAASjJ,UAEPqE,KADFN,MAASiH,aAAAA,aAAetC,IAGrByB,GACH3I,EAAEoI,gBAAkBpI,EAAEoI,iBAGxBpI,EAAEmI,iBAAmBnI,EAAEmI,kBAET3J,EAAQ8J,MAAK,SAACpG,UACnBA,EAAMpD,MAAQ+I,WAIhBuB,SAAS,CAAEtG,eAAgB+E,IAChC2B,EACEhL,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,OACrB,CAAEwE,eAAgB+E,IAEpBc,EAAU9F,KAAK4G,iBAAmB5G,KAAK6G,wBAElCN,SAAS,CAAEtG,eAAgB,UAC3B6G,yBAAyB3J,EAAG2I,4CAIrC,SAAyB3I,EAA4B2I,OAY/CjK,WARAmE,KAFF4E,MAAkBxG,IAATzC,QAAemJ,IAAAA,cAEtB9E,KADFN,MAASpD,IAAAA,aAAUhB,SAAAA,gBAMrBwJ,EAAYhB,UAAU1H,EAJH4D,KAAX3D,OAIqC0J,QAASzJ,IAOpDT,EAAciJ,EAAYjH,SAFxBiI,EAEiC5I,EAAiBZ,EAAUa,GAG3Bb,EAAWa,EAAEC,QAAUD,EAAEE,eAI1DzB,EAAY,GACZmL,EAAUC,SAELjJ,EAAI,EAAGA,EAAIK,EAAKpB,OAAQe,IAAK,OACfK,EAAKL,GAAlB9B,IAAAA,IACFgL,EAAO7F,KAAK8F,MADLzL,IACeI,GAExBoL,EAAOF,IACTnL,EAAYK,EACZ8K,EAAUE,OAKRtB,EAAcjK,EAClB0C,EACAxC,EACAC,EACAP,QAIGiL,SAAS,CAAEtG,eAAgBrE,IAAa,WAC3C6G,EAAKmD,aAAaD,GAAa,GAC/BG,EAAUrD,EAAKmE,iBAAmBnE,EAAKoE,kDA8B3C,WACM3C,IACFE,SAAS+C,iBAAiB,YAAanH,KAAKkG,aAC5C9B,SAAS+C,iBAAiB,UAAWnH,KAAKoG,0CAI9C,WACMlC,IACFE,SAAS+C,iBAAiB,YAAanH,KAAKmG,aAC5C/B,SAAS+C,iBAAiB,WAAYnH,KAAKyG,yCA0D/C,SAAavI,OAAoBkJ,4DAO3BpH,KAAKN,UALP2H,KAAAA,aAAO,QACP/I,KAAAA,aAAO,SACPgJ,SAAAA,aAAWjD,QACXgC,SAAAA,aAAWhC,QACX/I,SAAAA,gBAGMuC,EAAamC,KAAK4E,MAAMpH,YAAxBK,cAEH0I,UAAS,gBAAYnI,IAATzC,QACXA,EAAwB,MAGR,mBAAT0L,EACT1L,EAAU0L,EAAKjJ,EAAMF,EAAMI,EAAMhD,EAAUuC,GAC3CC,UACEyJ,MAAMC,QAAQ7L,GACd,6DAGM0L,QACD,EACH1L,EAAUqC,EAAMI,EAAMF,cAEnB,EACHvC,EAAUwC,EAAMC,EAAMF,cAEnB,EACHvC,EAAU0C,EAAMD,EAAMF,EAAMI,EAAMhD,EAAUuC,iBAG5ClC,EAAUuC,EACVJ,WAAQ,YAAU1C,kCAIxBkM,EAAS3L,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,QAE1B2L,GACFf,EAAS1K,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,QAGzB,CAAEE,QAAAA,4BA4Cb,wBAWMqE,KATF4E,MAAkBC,IAAAA,YAAa5E,IAAAA,iBAS7BD,KARFN,MACE+H,IAAAA,cACAC,UAAAA,aAAY,SACZC,UAAAA,aAAY,SACZC,UAAWC,aAAO,YAClBC,SAAAA,oBACAC,QAAAA,gBAIEC,IAXKrM,QAWmBgC,KAAI,gBAAQlC,IAAAA,UAEjC,CAAEqF,KAF0B7E,IAEjBoD,MAAO5D,EAAK6D,QAASuF,EAAYhH,SAASpC,OAGxD0E,EAAWE,UAAMC,SAAS3C,IAAIqC,KAAKN,MAAMS,UAAU,SAAC8H,UAC1B,IAlgBb,SAACC,OACjBC,iBAAeD,UACX,MAGHpL,EAAQoL,EAAsBpL,KAC9BsL,EAAOtL,EAAOA,EAAKsL,KAAO,UAG9BA,IAAS5H,EAAQ4H,MACjBA,IAAS7I,EAAK6I,MACdA,IAAShF,EAAMgF,MACfA,IAAS7E,EAAO6E,KAsfVC,CAAeJ,GACV5H,UAAMiI,aAAaL,EAA6B,CACrD5E,MAAOwB,EACPlJ,QAASqM,EACT/H,eAAAA,EACAG,aAAcmI,EAAKnI,aACnBW,aAAc+G,EAAWzD,EAAOkE,EAAKvH,UACrCpB,UAAWkI,EAAWzD,EAAOkE,EAAKzI,YAClCD,UAAWiI,EAAWzD,EAAOkE,EAAKxI,eAG7BkI,YAIJF,EACL1H,gDACGA,UAAMmI,cAAcX,SAChBF,OACHc,MAAOf,EACPD,UAAWA,EACXiB,IAAK1I,KAAK3D,UAEX8D,GAGHE,gDACGA,UAAMmI,cACLX,SAEKF,OACHc,MAAOf,EACPD,UAAWA,EACXiB,IAAK1I,KAAK3D,SAEZ8D,8CA9eR,SACEwI,EACAC,OAnEWrN,EAAQC,IA6EfmN,EAPFrK,KAAAA,aAAO,KACPf,EAMEoL,EANFpL,SAMEoL,EALFpH,OAAAA,aAASkD,MAKPkE,EAJFrN,SAAAA,kBAIEqN,EAHFrB,SAAAA,aAAWjD,MAGTsE,EAFFtC,SAAAA,aAAWhC,MAETsE,EADFE,cAAAA,gBAEEhE,EAAc+D,EAAU/D,YACxBrH,EAAcoL,EAAUpL,YACxBsH,EAAc8D,EAAU9D,YAEtBgE,EAAkC,MAEnCjE,GAAgBrH,GAAgBsH,IACnCD,EAAc,IAAIxD,EAClB7D,EAAc,IAAIqG,EAClBiB,EAAc,IAAIb,EAElB6E,EAAUjE,YAAcA,EACxBiE,EAAUtL,YAAcA,EACxBsL,EAAUhE,YAAcA,GAIxB8D,EAAUrH,SAAWkD,GACF,OAAnBmE,EAAUtK,MACW,OAArBsK,EAAUrH,QACa,OAAvBqH,EAAUtN,UACVgD,IAASsK,EAAUtK,MACnBiD,EAAO,KAAOqH,EAAUrH,OAAO,IAC/BA,EAAO,KAAOqH,EAAUrH,OAAO,IAC/BjG,IAAasN,EAAUtN,SACvB,SACmBiG,KAAZL,OAAKC,OACZ3D,EAAYwG,QAAQ1F,GAAMyF,SAAS,CAAC7C,EAAKC,IAAM2C,UAAU,CAAC5C,EAAKC,KAE9C,IAAb7F,GACFuJ,EAAYf,UAAU,CAAC5C,EAAKC,IAAM4C,SAAS,CAAC,IAAK,IACjDe,EAAYd,QAAQ1F,GAAMyF,SAAS,CAAC5C,EAAKD,MAEzC2D,EAAYf,UAAU,CAAC5C,EAAKC,IAAM4C,SAAS,CAAC,EAAG,MAC/Ce,EAAYd,QAAQ1F,GAAMyF,SAAS,CAAC7C,EAAKC,KAG3CrD,UACEqD,EAAMD,YACH9F,sEAAgE+F,sBAAeD,cAGvD5D,EAC3BC,GAAUqL,EAAUrL,OACpBjC,EACAkC,EACAqL,GAJMlN,IAAAA,WAAS+B,cAOSqL,IAAXxL,GAAwBA,IAAWqL,EAAUrL,UAC1D+J,EAAS3L,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,QAC9B4K,EAAS1K,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,SAGhCqN,EAAUxK,KAAOA,EACjBwK,EAAUvL,OAASA,EACnBuL,EAAUvH,OAASA,IAAWkD,IAAoBlD,GAAUA,EAC5DuH,EAAUnN,QAAUA,EACpBmN,EAAUxN,SAAWA,OAChB,MAzIIC,EAyIOgC,MAzIC/B,EAyIOoN,EAAUrL,SAxInBhC,EAAEyB,SAAWxB,EAAEwB,QAAUzB,EAAEyN,OAHhC,SAACxN,UAAa,SAACyN,EAAQhG,EAAQlF,UAAckL,GAAKzN,EAAEuC,KAAOkF,GAGpBiG,CAAQ1N,IAAI,IAwIlB,OACd8B,EAC3BC,EACAjC,EACAkC,EACAqL,GAJMlN,IAAAA,UAAS+B,UAQf4J,EAAS3L,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,QAC9B4K,EAAS1K,EAAQgC,KAAI,SAACsF,UAAMA,EAAExH,SAGhCqN,EAAUvL,OAASA,EACnBuL,EAAUnN,QAAUA,SAGlBwN,OAAOC,KAAKN,GAAW9L,OAClB8L,EAGF"}